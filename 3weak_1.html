<HTML>
    <HEAD>
      <TITLE>3weak_1</TITLE>
    </HEAD>
    <BODY>
        </br>
        <b><font size=+3>REVIEW</font></b></br>
            </br>
            <b><font size=+2>GO 언어</font></b></br>
            GO 언어는 전통적인 컴파일, 링크 모델을 따르는 범용 프로그래밍 언어이다.</br>
            이 언어는 일차적으로 시스템 프로그래밍을 위해 개발되었으며, C++, Java, Python의 장점들을 뽑아 만들어졌다.</br>
            C++와 같이 GO 언어는 컴파일러를 통해 컴파일되며, 정적 타입(Statically Typed)의 언어이다.</br>
            또한 Java와 같이 GO 언어는 Garbage Collection 기능을 제공한다.</br>
            단순하고 간결한 프로그래밍 언어를 지향하였는데, Java의 절반에 해당하는 25개의 키워드만으로 프로그래밍이 가능하게 하였다.</br>
            GO 언어의 가장 큰 특징으로 Communicating Sequential Processes(CSP) 스타일의 Concurrent 프로그래밍을 지원한다.</br>
            <b><font size=+2>RUST 언어</font></b></br>
            RUST는 모질라 리서치에서 개발한 범용 프로그래밍 언어이다.</br>
            안전하고, 병렬적이며, 실용적인 언어를 목표로 디자인되었으며, 순수 함수형 프로그래밍, 액터 기반 병렬 프로그래밍, 명령형 프로그래밍, 객체 지행 프로그래밍 스타일을 지원한다.</br>
            RUST의 빌드 시스템은 cargo라는 이름의 빌드 시스템이다.</br>
            RUST는 병행처리 및 메모리 자원 누수방지등의 언어 철학 바탕위에 설계된 취지에 맞게 안전성으로 제작된 프로그램은 빌드 과정에서 사전에 불안정한 결과를 방지할 수 있다는 빌드시스템으로까지 이어지는 완전한 안정성을 실현한다.</br>
            RUST는 인터넷에서 실행되는 서버 및 클라이언트 프로그램을 개발하는데 적합한 언어를 목표로 설계되었다.</br>
            이 목표에 따라 RUST는 안전성과 병행 프로그래밍, 그리고 메모리 관리의 직접 제어에 초점을 맞추고 있다.</br>
            또한 성능 면에서는 C++와 비슷한 수준을 목표로 하고 있다.</br>
            RUST의 이점은 아래와 같다.</br>
            </br>
            <b>1. 메모리 관리</b></br>
            RUST는 컴파일러 수준에서 메모리 안전성을 검증하는 소유권과 대여 체계를 도입했다.</br>
            언어 자체에서 소유권 시스템을 제공하여 명확한 소유권과 참조 체크 규칙으로 메모리 관리가 컴파일중에 검증되어 눈에 띄게 메모리의 안전성이 높아진다.</br>
            이를 통해 런타임 오류를 최소화하고 메모리 누수, 무효 포인터 참조 등의 문제를 해결할 수 있다.</br>
            개발자는 메모리 할당과 해제를 명시적으로 다루지 않아도 되고, 동시성 문제와 메모리 오류로부터 안전한 코드를 작성할 수 있도록 한다.</br>
            </br>
            <b>2. 동시성과 병렬성</b></br>
            멀티태스킹 환경에서 복잡한 동시성 문제를 관리하고 다루기 쉽게 한다.</br>
            RUST는 안전한 동시성을 제공하기 위해 스레드 안전성을 강조한다.</br>
            안전한 멀티스레딩과 초보자도 사용하기 쉬운 동기화 도구를 제공하며, 이를 통해 높은 성능과 코드의 안전성을 보장한다.</br>
            컴파일러는 데이터 경합과 다른 스레딩 관련 문제를 검사하고 스레드 간 안전한 동시 접근을 보장한다.</br>
            이는 병렬 처리와 동시성을 효과적으로 다룰 수 있게 해준다.</br>
            </br>
            <b>3. 고성능</b></br>
            RUST는 C, C++ 같은 저수준 언어로, 컴파일 중 최적화를 포함하여 최적의 성능을 보여준다.</br>
            런타임에 가비지 컬렉터가 없어 실행 속도와 메모리 사용에 있어서 높은 효율성을 가진다.</br>
            RUST의 제로 비용 추상화(zero-cost abstractions) 기능은 개발자가 추상화를 사용할 때 성능 손실을 최소화할 수 있도록 해준다.</br>
            RUST의 컴파일러는 최적화에 강하고 효율적인 기계어 코드를 생성한다.</br>
            </br>
            <b>4. 언어 기능의 생산성</b></br>
            RUST는 표현력이 높고 재사용 가능한 코드를 작성할 수 있는 언어 기능들이 잘 구현되어 있어 사용 편의성이 높다.</br>
            강력한 타입 추론 시스템과 패턴 매칭, 함수형 프로그램등의 기능으로 높은 수준의 코드 유지보수성과 가독성을 가진다.</br>
            또, 코드 작성을 단순화하여 개발 과정을 빠르고 효율적으로 만들어 준다.</br>
            </br>
            <b>5. 확장성과 유지보수성</b></br>
            개발자가 코드를 구조화하고 재사용 가능한 컴포넌트로 만들 수 있으며, 높은 수준의 코드 재사용과 유지보수성을 지원한다.</br>
            </br>
            <b>6. 크로스 플랫폼 지원</b></br>
            RUST는 다양한 플랫폼에서 동작되도록 설계되었다.</br>
            Windows, macOS, Linux뿐만 아니라 임베디드 시스템, WebAssembly등 다양한 환경에서도 쉽게 빌드하고 실행할 수 있다.</br>
            이를 통해 개발자들은 다양한 환경에서의 호환성을 걱정할 필요가 없다.</br>
            </br>
            <b>7. 활발한 커뮤니티 생태계</b></br>
            RUST는 커뮤니티의 지속적인 기여를 받고 있고, 많은 개발자들이 활발하게 RUST를 사용하고 지원한다.</br>
            커뮤니티를 통해 개발 문서화, 라이브러리, 도구, 프레임워크 등의 생태계를 발전시키고, 문제 해결과 지원을 보다 쉽게 얻을 수 있도록 해준다.</br>
            많은 라이브러리와 도구가 오픈소스로 개발되어 있어 게임 개발, 웹 어셈블리, 서버 개발, IoT 및 기타 많은 프로젝트에서 RUST를 사용 가능하다.</br>
            RUST의 생태계는 라이브러리 및 프레임워크 등을 계속 발전하고 있고, 수준 높은 생산성을 제공한다.</br>
            </br>
            <b><font size=+2>scanf의 문자열 매칭</font></b></br>
            scanf는 C언어에서 문자열을 입력받는 방법 중 하나이다.</br>
            scanf는 주어진 문자열 스트림 소스에서 지정된 형식으로 데이터를 읽어내는 기능이다.</br>
            입력한 문자열의 특정한 배치를 위한 다양한 기능에서 사용되는 매개 변수를 통제하는 것이다.</br>
            </br>
            <b><font size=+2>C언어 헤더 파일</font></b></br>
            헤더 파일은 컴파일러에 의해 다른 소스 파일에 자동으로 포함된 소스 코드의 파일이다.</br>
            일반적으로 헤더 파일들은 다른 소스 파일 속의 첫 부분에 포함된다.</br>
            C언어에서 표준 라이브러리 함수는 전통적으로 헤더 파일 안에서 선언되어 있다.</br>
            함수들은 API 수준에서 이해하거나 알 수 있어야 한다.</br>
            개발 도구를 만드는 입장에서, 함수 자체를 설계하고 코딩을 한 측에서 제공해야 한다.</br>
            라이브러리 오브젝트 코드는 파일로 존재하고 헤더 파일에 함수나 변수의 형이 선언되어 있으므로 사용자 측에서 붙여 사용할 수 있다.</br>
            사용자 측에서 사용한 라이브러리는 라이브러리 파일의 코드를 링커가 응용 프로그램에 붇여 전체 실행 코드가 완성된다.</br>
            헤더 파일의 형을 사용하여 라이브러리 사용자의 인클루드에 의해 함수 호출 방식이 결정된다.</br>
            예를 들어, printf라는 함수를 C언어에서 사용한다고 가정한다.</br>
            printf 함수는 stdio.h 표준 라이브러리에 존재하고 stdio.h 헤더 파일에 형이 선언 되어 있다.</br>
            </br>
            <b><font size=+2>C++의 cout, cin과 C의 printf, scanf와의 차이</font></b></br>
            <b>C++의 cout, cin</b></br>
            C++의 cout와 cin은 C++ 표준 라이브러리(iostream)에 정의된 객체이다.</br>
            cout는 출력 흐름(output stream) 객체이며, 표준 출력 장치(console)나 파일에 연속적으로 출력할 수 있다.</br>
            이 객체를 사용하여 사용자가 입력한 값을 출력하거나, 프로그램이 생성한 결과를 표시할 수 있다.</br>
            cin은 입력 흐름(input stream) 객체이고, 표준 입력 장치나 파일에서 연속적으로 입력할 수 있다.</br>
            이 객체를 사용하여 사용자로부터 입력을 받아올 수 있다.</br>
            따라서, cout는 출력을 다루는 객체이고, cin은 입력을 다루는 객체이다.</br>
            </br>
            <b>C의 printf, scanf</b></br>
            C언어에서 입출력을 담당하고 printf는 cout, scanf는 cin과 유사하다.</br>
            printf 함수는 사용자가 입력한 값이나 프로그램이 생성한 결과를 형식에 맞추어 화면에 출력하는 데 사용한다.</br>
            scanf는 사용자가 입력한 값을 변수에 저장하는 데 사용한다.</br>
            이 함수는 형식 지정자를 사용하여 사용자에게 입력받을 데이터의 형식을 지정하고, 변수의 주소를 인자로 전달하여 입력받은 값을 해당 변수에 저장한다.</br>
            두 함수 모두 형식 지정자를 사용하여 다양한 자료형의 값을 처리할 수 있다.</br>
            </br>
            <b><font size=+2>포인터(*)와 참조(&)의 차이</font></b></br>
            포인터는 메모리 주소를 저장하는 변수이다.</br>
            이러한 변수는 일반 변수와 다른 방식으로 다룰 수 있다.</br>
            참조는 변수에 담긴 값을 직접적으로 참조하는 것이다.</br>
            참조를 이용하면 해당 변수에 할당된 값을 직접적으로 가져올 수 있다.</br>
            포인터는 메모리 주소를 직접 다루지만 참조는 그냥 값 자체를 서로 연결시키는 개념이다.</br>
            </br>
            <b><font size=+2>함수 포인터와 람다(익명) 함수</font></b></br>
            함수 포인터는 C언어에서 함수의 메모리 주소를 저장하는 변수이다.</br>
            함수 포인터를 사용하면 함수를 변수처럼 전달하거나 사용할 수 있어 프로그램의 확장성과 유연성을 높일 수 있다.</br>
            또, 함수를 다른 함수의 인수로 전달하거나 배열에 저장하는 등 유연한 프로그래밍 방식을 지원한다.</br>
            특정 상황에 따라 다른 함수를 동적으로 선택하는 기능을 구현할 수도 있다.</br>
            람다 함수는 일회성으로 사용되는 함수를 쉽게 선언할 때 사용된다.</br>
            함수를 간결하게 표현하고, 코드를 보다 가독성 있게 만드는데 도움을 준다.</br>
            람다 함수는 일반적으로 다른 함수의 인자로 전달하거나, 함수의 결과로 반환하는 경우에 활용된다.</br>
            </br>
            <b><font size=+2>콜백 함수와 콜백 지옥</font></b></br>
            콜백 함수는 다른 함수에 의해 호출되어 실행되는 함수를 말한다.</br>
            이 함수는 특정 이벤트나 조건이 충족되었을 때 실행되도록 프로그램에서 사용된다.</br>
            예를 들어, 이벤트 기반의 프로그래밍에서 UI 버튼을 클릭하면 버튼 클릭 이벤트가 발생하고, 이로 인해 정의된 콜백 함수가 호출되어 원하는 동작을 수행한다.</br>
            콜백 함수의 사용용도는 주로 비동기 작업이 완료된 후 결과를 처리하거나 특정 이벤트에 대한 처리를 제공하는 데 사용된다.</br>
            콜백 함수에서 일어나는 현상 중 콜백 지옥이라는 것이 있다.</br>
            콜백 지옥은 비동기 프로그래밍에서 흔히 발생하는 문제로 여러 콜백 함수가 중첩되어 사용되면 코드의 가독성과 유지 관리가 어렵게 되는 상황을 말한다.</br>
            주로 javascript에서 이러한 현상이 나타난다.</br>
            콜백 지옥은 비동기 작업이 연속으로 이루어져야 하는 경우에 특히 발생할 확률이 높다.</br>
            예를 들어,</br>
            function1(function()) {</br>
              &nbsp;function2(function()) {</br>
                &nbsp;&nbsp;function3(function()) {</br>
                  &nbsp;&nbsp;...</br>
                  &nbsp;&nbsp;}</br>
                  &nbsp;}</br>
            }</br>
            콜백 지옥은 코드 구조가 복잡하고 가독성이 떨어져서 에러를 발견하거나 수정하기 어려울 뿐만 아니라, 로직의 흐름을 파악하기 힘들게 한다.</br>
            콜백 지옥을 해결하기 위해 위 방법들을 적절히 사용하여 코드 구조를 개선할 수 있다.</br>
            </br>
            <b><font size=+2>C++ auto 타입과 제네릭 타입</font></b></br>
            C++에서 auto 타입은 자동 유추 타입이다.</br>
            auto를 사용하면 컴파일러가 표현식의 타입을 자동으로 결정할 수 있다.</br>
            이는 코드를 더 간결하고 가독성을 높여주고 특히, 복잡한 타입의 이름을 작성하는 것이 번거로울 경우 유용하게 사용된다.</br>
            auto를 사용할 때 주의할 점은 타입을 명시적으로 작성하는 것이 코드의 가독성을 높이는 경우 auto 대신 원래의 타입을 사용해야 한다.</br>
            그리고 프로그래머의 의도와 다르게 컴파일러에게 잘못된 타입이 유추될 수 있으므로 신중하게 사용해야 한다.</br>
            제네릭 타입도 auto와 같이 타입에 관련되어 있다.</br>
            제네릭 타입은 프로그래밍 언어에서 범용 코드를 작성할 수 있게 해주는 기능이다.</br>
            제네릭 타입을 사용하면 합수나 클래스에서 작업을 수행하는 동안 데이터 타입이 결정되지 않은 변수를 선언할 수 있다.</br>
            java, C++, C#, Swift 등에서 제네릭을 지원한다.</br>
            </br>
            <b><font size=+2>void 포인터와 malloc</font></b></br>
            void 포인터는 가리키는 데이터 타입이 정해지지 않은 포인터로, 어떠한 데이터 타입의 주소라도 가질 수 있다.</br>
            이러한 특성 때문에 void 포인터는 일반적으로 범용적인 함수 인자로 사용되거나, 여러 타입의 객체들을 관리하는 경우에 쓰인다.</br>
            주의해야 할 것은, void 포인터로부터 다른 포인터 타입으로 형변환을 할 때는 주의가 필요하고 잘못된 형변환이 원치 않은 결과를 가져올 수 있다는 점이다.</br>
            때문에 void 포인터를 사용할 때는 형변환에 특별한 주의를 기울여야 한다.</br>
            </br>
    </BODY>
</HTML>