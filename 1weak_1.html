<HTML>
    <HEAD>
      <TITLE>1weak_1</TITLE>
    </HEAD>
    <BODY>
        </br>
        <b><font size=+3>REVIEW</font></b></br>
            </br>
            <b><font size=+2>깃 명령</font></b></br>
                </br>
                <b><font size=+1>add</font></b></br>
                working directory상의 변경 내용을 staging area에 추가하기 위해 사용하는 명령어.</br>
                staging 할때 파일과 폴더를 모두 arguments로 받는다.</br>
                </br>
                <b><font size=+1>commit</font></b></br>
                staging area에 저장됐던 파일이 local repository로 확정된다.</br>
                commit을 하면 stage영역은 초기화된다.</br>
                </br>
                <b><font size=+1>diff</font></b></br>
                commit이나 branch사이에 다른점 혹은 파일이나 repository와 working directory사이의 다른 점을 보여주는 명령어.</br>
                branch는 코드를 복사해 이용할 경우, 원래 코드와는 상관없이 독립적으로 개발을 진행할 수 있는 것이 branch이다.</br>
                </br>
                <b><font size=+1>pull</font></b></br>
                github에 관련된 repository는 local repository(개인 저장소)와 remote repository(원격 저장소)가 있다.</br>
                개인 저장소에서 원격 저장소로 push한 버전을 원격 저장소에서 개인 저장소로 가져오고 싶을 때 pull 명령어를 사용한다.</br>
                좀더 자세하게 pull 명령어는 원격 저장소에서 변경된 데이터 정보를 확인하면서 최신 데이터를 복사하여 개인 저장소로 가져온다.</br>
                하지만 pull 명령어를 데이터를 가져오기 위해 바로 사용하면 파일이 변경되는 등 새로 작업한 내용이 손실될 수 있기 때문에 fetch를 먼저 사용하고 그 다음 pull을 사용하는 것이 안전하다.</br>
                </br>
                <b><font size=+1>fetch</font></b></br>
                fetch 명령어는 위에 서술된 pull 명령어와 비슷한 작업을 수행한다.</br>
                비슷하지만 pull 명령어와는 차이가 있는데, pull은 최신 데이터를 복사하여 개인 저장소에 들고오는 작업도 수행한다.</br>
                하지만 fetch는 원격 저장소에서 변경된 데이터 정보를 확인하라는 명령만 전달할 뿐, 변경된 데이터를 개인 저장소에 가져오지는 않는다.</br>
                fetch를 사용하면 마지막에 사용한 pull이후 원격 저장소 또는 브랜치에 적용된 변경 사항을 확인할 수 있다.</br>
                </br>
                <b><font size=+1>reset(checkout)</font></b></br>
                reset 명령어와 checkout 명령어 모두 git에서 작업 기록을 이동시키는 명령어이다.</br>
                하지만 이 두 명령어는 서로 다른 명령어이기 때문에 차이점이 존재한다.</br>
                reset 명령어는 현재 brench의 head를 이전 commit 또는 특정 commit으로 이동시키는 데 사용한다.</br>
                주로 사용하는 상황은 잘못된 commit을 취소하거나, commit된 변경 사항을 되돌리는 데 사용한다.</br>
                checkout 명령어는 working directory의 파일과 폴더를 특정 commit, branch, tag로 변경하는 데 사용한다.</br>
                주로 사용하는 상황은 이전 commit, 다른 branch, tag에 대한 변경사항을 검토하거나 다른 branch로 전환하는데 사용한다.</br>
                또한, working directory의 특정 파일을 이전 상태로 되돌릴 때에도 사용할 수 있다.</br>
                </br>
                <b><font size=+1>restore</font></b></br>
                restore 명령어는 working directory의 파일을 staging area 또는 특정 commit의 상태로 복원하는 데 사용한다.</br>
                만약 staging 영역으로 복원하고 싶다면 '--staged (file)'을 쓰고 특정 commit을 복원하고 싶다면 '--source=(commit) (file)'의 형식으로 사용한다.</br>
                </br>
                <b><font size=+1>status</font></b></br>
                working directory와 staging area의 상태를 보여주는 명령어.</br>
                working directory와 staging area에 있는 변경된 파일, 추가된 파일, 삭제된 파일 등의 정보를 확인 가능하다.</br>
                현재 작업중인 branch도 확인 가능하며 보통, 파일 변경 사항을 commit하기 전에 어떤것이 변경되었는지 확인할 때 유용하다.</br>
                </br>
                <b><font size=+1>log</font></b></br>
                commit의 log 및 다른 추가적인 정보를 조회할때 사용.</br>
                commit 기록, commit의 메세지, 작성자, 날짜, commit ID 등의 정보를 확인 가능하다.</br>
                </br>
            <b><font size=+2>CLI</font></b></br>
            사용자와 컴퓨터 시스템 간 상호 작용을 위한 텍스트 기반의 인터페이스.</br>
            컴퓨터가 CLI 명령어를 해석하고 진행한 다음, 결과를 텍스트로 보여준다.</br>
            사용자는 키보드로 명령어를 입력하여서 프로그램을 실행하고, 시스템 설정을 변경하는 등, 컴퓨터에 있는 리소스를 관리할 수 있다.</br>
            보통의 운영체제들이 이런 형식을 지원하며 대표적으로 windows, mac, linux 등이 여기에 포함된다.</br>
            </br>
            <b><font size=+2>GUI</font></b></br>
            CLI은 텍스트를 기반으로 사용자에게 정보를 제공한다.</br>
            하지만 텍스트 만으로는 가독성이 떨어질 수도 있고 표현방식이 한정되있기 때문에 사용자 입장에서는 불편함을 야기할 수 있다.</br>
            반면 GUI는 아이콘, 버튼, 창, 메뉴 등 텍스트 이외의 시각적 요소들도 포함해 사용자에게 정보를 제공한다.</br>
            GUI에서 사용자는 마우스, 터치, 키보드 등의 입력장치를 사용해서 시스템을 이용한다.</br>
            windows 운영체제 자체도 GUI에 속한다.</br>
            </br>
            <b><font size=+2>쓰레드</font></b></br>
            프로세스 내에서 실행되는 작업의 흐름 단위.</br>
            각 쓰레드는 스택, 레지스터 등을 갖고 있고 각각 독립적으로 실행된다.</br>
            이를 기반으로 다중 쓰레드를 사용하면 어떤 하나의 작업이 다른 작업을 방해하지 않고 동시에 작업이 수행되거나 교차로 실행될 수 있다.</br>
            멀티태스킹이 가능해 여러가지 작업을 동시에 수행하므로 성능 향상, 효율성 향상 등을 기대할 수 있다.</br>
            </br>
            <b><font size=+2>문맥교환</font></b></br>
            운영체제가 프로세스나 쓰레드 전환을 수행한다.</br>
            이는 실행 중인 프로세스의 정보를 저장하고 다음 프로세스의 문맥을 불러오는 과정을 밟는다.</br>
            이런 문맥교환의 과정을 통해 컴퓨터 시스템에서 동시에 여러 작업이 실행되게 할 수 있다.</br>
            보통 문맥교환이 발생하면 시스템 성능이 저하될 수 있다.</br>
            위에 서술한 일련의 과정이 시간을 소요하기 때문이다.</br>
            그러므로 프로세스가 딜레이 없이 원할하게 실행되려면 알고리즘 자체가 최적화 되있거나 문맥교환을 최소환으로만 해서 시스템 성능을 유지해야 한다.</br>
            </br>
            <b><font size=+2>REST-API</font></b></br>
            웹 서비스에 접근하기 위한 설계 원칙 및 아키텍처 스타일이다.</br>
            리소스에 대한 상호작용이 가능하게 하고, 일반적으로는 HTTP 프로토콜을 사용해 서버와 클라이언트 간에 통신을 구현한다.</br>
            사용하기 쉽고, 확장성이 뛰어나 기능을 추가하거나 수정할 수 있기 때문에 선호되는 웹 서비스 설계 방식이다.</br>
            </br>
            <b><font size=+2>html-css-js</font></b></br>
            html, css, js 모두 웹 개발의 핵심 언어이다.</br>
            이 세 언어는 웹 페이지의 구조, 스타일, 상호 작용을 담당하며 하나만 사용하는 것이 아닌 함께 사용하여 웹 콘텐츠를 제작한다.</br>
            </br>
            - html이 웹 페이지의 구조 즉, 텍스트, 이미지, 링크, 폼 등의 웹 페이지의 요소를 나타내기 위한 태그를 사용해 웹 문서를 작성하며, 뼈대 역활을 한다.</br>
            </br>
            - css는 웹 페이지의 스타일을 꾸미는 언어로 html 구조에 스타일, 레이아웃 등을 적용한다.</br>
            텍스트의 색상, 글꼴, 배경색, 여백 등 웹 페이지의 시각적 요소를 담당한다.</br>
            </br>
            - js는 웹 페이지에 상호작용 기능을 추가해주는 언어이다.</br>
            데이터 유효성 검사, 상호 작용 요소, 동적 콘텐츠 생성 등의 기능을 구현할 수 있게 한다.</br>
            기능성을 높이고 사용자 경험을 개선하는데 도움을 준다.</br>
            </br>
            <b><font size=+2>nginx</font></b></br>
            nginx는 웹 서버, 프록시 서버, 리버스 프록시 서버, 로드 밸런서, 메일 프록시 서버 등의 기능을 제공하는 고성능, 고확장성을 가진 오픈 소스 소프트웨어이다.</br>
            처음에는 웹 서버 그 자체로 개발되었지만 다양한 기능을 추가하여 오픈 소스 소프트웨어로 발전했다.</br>
            웹 사이트, 웹 애플리케이션의 성능 개선과, 안정성을 높이는데 사용된다.</br>
            </br>
            <b><font size=+2>IP</font></b></br>
            인터넷에서 데이터 패킷을 주고받는 데 사용되는 일종의 약속이다.</br>
            컴퓨터 네트워크에서 통신하는 장치들 사이에서 주소 지정 및 패킷 라우팅을 담당한다.</br>
            인터넷의 기반을 이루는 것이 이 IP이며 IPv4, IPv6 라고 불리는 주요 버전이 있다.</br>
            </br>
            - IPv4는 보편적으로 사용되는 IP 버전으로 32비트 크기의 주소를 사용하여 약 43억개의 주소를 할당 가능하다.</br>
            이 버전의 주소는 "192.168.0.1"과 같이 표현된다.</br>
            </br>
            - IPv6는 IPv4 주소의 고갈을 막기위해 도입된 버전이다.</br>
            128비트 주소를 사용해서 IPv4 주소의 고갈을 막고 더 많은 주소 할당이 가능해졌다.</br>
            이 버전의 주소는 "2001:0abc:a882:...:1234"와 같이 표현된다.</br>
            </br>
            <b><font size=+2>TCP와 UDP</font></b></br>
            이 둘은 인터넷 프로토콜 스택에서 데이터 전송을 처리하는 주요 전송 프로토콜들이다.</br>
            데이터를 패킷 단위로 분할하고 목적지에 전송한 후 원래 형태로 다시 조합하는 기능을 수행한다.</br>
            비슷하지만 통신 접근 방식이 다르며, 서로 다른 목적으로 사용된다.</br>
            예를 들어 TCP는 통신 전에 클라이언트와 서버 간에 연결을 설정하고 통신이 끝나면 연결을 해제한다.</br>
            반면 UDP는 통신 전에 클라이언트와 서버 간에 연결을 설정하지 않는다.</br>
            그리고 TCP에 비해 UDP는 데이터의 전송을 확인하지 않기에 데이터가 손실될 우려가 있다.</br>
            </br>
            <b><font size=+2>리눅스와 유닉스</font></b></br>
            다중 사용자, 다중 작업을 지원하는 운영체제들이다.</br>
            시스템 구조, 명령어, 프로세스 관리 등이 유사하지만 차이점이 존재한다.</br>
            유닉스는 기업에서 주로 사용되는 다양한 상용 버전이 있다.</br>
            리눅스는 무료 오픈 소스 운영체제로 다양한 배포판들이 있어 사용자에 요구에 맞게 정의할 수 있다.</br>
            </br>
    </BODY>
</HTML>