<HTML>
    <HEAD>
      <TITLE>3weak_2</TITLE>
    </HEAD>
    <BODY>
        </br>
        <b><font size=+3>REVIEW</font></b></br>
            </br>
            <b><font size=+2>빅 엔디안과 리틀 엔디안</font></b></br>
            빅 엔디안과 리틀 엔디안은 컴퓨터 시스템에서 바이트 순서를 나타내는 용어이다.</br>
            여러 바이트로 구성된 데이터의 저장 및 처리 방식에 대한 용어로, 서로 다른 방식을 사용하는 시스템 간 데이터 교환에 문제가 발생할 수 있다.</br>
            빅 엔디안은 가장 중요한 바이트가 가장 작은 주소에 위치하도록 데이터를 메모리에 저장한다.</br>
            예로, 4바이트 정수 0x12345678에서 0x12가장 큰 바이트이므로 이 값을 낮은 메모리 주소에 위치시키는 방식이다.</br>
            빅 엔디안은 우리가 숫자를 일상적으로 사용하는 왼쪽에서 오른쪽으로 읽는 방식과 유사하여, 사람이 읽을 때 보통 편하다고 느낀다.</br>
            리틀 엔디안은 가장 작은 중요도의 바이트를 가장 작은 주소에 배치한다.</br>
            위 4바이트 정수를 그대로 이용하여 0x12345678의 경우 0x78이 가장 작은 바이트이므로 이 값을 낮은 메모리 주소에 위치시키는 방식이다.</br>
            이 방식은 특정한 산술 작업을 수행할 때 더욱 효율적이라고 여겨진다.</br>
            두 방식은 서로 장단점이 있으며 Intel 프로세서는 주로 리틀 엔디안을, 모토로라와 파워PC는 빅 엔디안을 사용한다.</br>
            </br>
            <b><font size=+2>C인라인 어셈블리</font></b></br>
            C언어 코드 내에 직접 어셈블리 코드를 삽입할 수 있는 기능이 C인라인 어셈블리이다.</br>
            인라인 어셈블리를 사용하면 프로그래머가 로우레벨의 작업을 수행하거나 특정 프로세서 인스트럭션을 호출하는 등, C 언어에서 제공하지 않는 다양한 기능을 사용할 수 있다.</br>
            이 기능은 컴파일러가 코드를 최적화하기 어려운 경우나 특정 시스템 자원에 접근할 필요가 있을 때 유용하다.</br>
            하지만 잘 사용하지 못 할 경우, 컴파일러가 레지스터 할당 등 시스템 리소스에 대한 관리를 효과적으로 수행할 수 없어 성능 저하가 발생할 수 있다.</br>
            그러므로 프로그래머는 인라인 어셈블리 코드가 필요한 경우만 사용하고 대부분의 경우는 C언어 기본 기능을 사용하는 것이 좋다.</br>
            </br>
            <b><font size=+2>파일 리버싱</font></b></br>
            파일 리버싱은 컴퓨터 프로그램의 소스 코드나 실행 파일의 구조와 작동 원리를 역으로 분석하는 과정 그 자체이다.</br>
            파일 리버싱은 주로 이진 파일, 혹은 실행 파일을 분석하는데 활용되며 이러한 파일들은 이미 컴파일되어 사람이 읽기 어려운 형태로 존재한다.</br>
            파일 리버싱을 하는 주요 목적은 다음과 같다.</br>
            </br>
            <b>1. 보안 분석</b></br>
            악성 코드나 바이러스를 분석하여 작동 원리와 행위를 이해하는데 사용한다.</br>
            이를 통해 악성 코드를 차단하거나 제거하는 방법을 개발할 수 있다.</br>
            </br>
            <b>2. 소프트웨어 보호</b></br>
            저작권 보호, 라이선스 확인, 암호화, 난독화 기술을 사용해 소프트웨어를 보호하는 방법을 검증하거나 향상할 수 있다.</br>
            </br>
            <b>3. 호환성 확보</b></br>
            소프트웨어나 하드웨어의 호환성을 확인하거나 더 이상 원본 소스 코드가 없는 시스템을 유지보수하려는 경우 리버싱 과정을 거쳐 새로운 구현을 만든다.</br>
            </br>
            <b>4. 기술 연구</b></br>
            프로그램의 작동 원리나 특정 기능을 분석하여 프로그래머의 기술력을 향상시키거나 경쟁력 있는 다른 소프트웨어를 개발하는데 활용할 수 있다.</br>
            </br>
            <b><font size=+2>C--</font></b></br>
            C--는 시스템 프로그래밍과 운영체제 개발에 사용되기 위해 설계된 로우 레벨 프로그래밍 언어이다.</br>
            C--는 기계어 어셈블리와 하이레벨 프로그래밍 언어 사이에서 매개 역할을 수행하도록 개발되었다.</br>
            이 언어는 컴파일러 뒷단에서 사용되는 목적을 염두해 두고 설계되었기 때문에 프로그래머들이 직접 C--코드를 작성하는 것에 큰 편의를 제공하지 않는다.</br>
            하지만 컴파일러가 고수준 프로그래밍 언어로부터 생성한 중간 코드를 다루기 쉽게 하도록 도울 수 있다.</br>
            C--의 주요 특징은 아래와 같다.</br>
            </br>
            <b>1. 단순한 구조</b></br>
            언어 구조와 명령어 집합이 단순하고 이를 구현하기 쉽다.</br>
            </br>
            <b>2. 최적화에 용이</b></br>
            컴파일러를 통해 소스 코드의 최적화를 수행하기 편하다.</br>
            </br>
            <b>3. 기계어와의 타이트한 연결</b></br>
            프로세서의 특정한 기계어에 직접 매핑할 수 있어서 효율적인 코드 생성이 가능하다.</br>
            </br>
            <b>4. 이식성</b></br>
            여러 플랫폼 및 프로세서에서 동일한 이식성을 제공한다.</br>
            </br>
            <b><font size=+2>바이너리 코드와 보는 방법</font></b></br>
            바이너리 코드는 컴퓨터가 이해하고 실행할 수 있는 0과 1로 구성된 기계어 코드이다.</br>
            보통 프로그래머가 작성한 고수준 프로그래밍 언어의 소스 코드는 컴파일러나 인터프리터를 통해 기계어로 변환된 후 하드웨어에서 직접 실행된다.</br>
            CPU가 실제로 해석하고 실행할 수 있는 명령어로 구성되어 있다.</br>
            대부분의 컴퓨터 시스템은 이진수를 기반으로 데이터 저장 및 연산을 수행하기 때문에 바이너리 코드는 처리 효율이 높다.</br>
            바이너리 코드의 주요 특징은 아래와 같다.</br>
            </br>
            <b>1. 가독성 부족</b></br>
            0과 1로만 구성되어 있기 때문에 사람이 읽거나 이해하는 것이 어렵다.</br>
            </br>
            <b>2. 하드웨어 의존성</b></br>
            특정 CPU 아키텍처에 맞춰져 있어서 다양한 플랫폼 및 프로세서에 바로 실행되지 않을 수 있다.</br>
            </br>
            <b>3. 최적화 가능성</b></br>
            높은 수준의 최적화를 통해 실행 속도와 메모리 사용량을 줄일 수 있다.</br>
            </br>
            <b><font size=+2>함수 호출 방식(cdecl, stdcall, fastcall)</font></b></br>
            함수 호출 방식들은 컴파일러가 함수 호출, 매개변수 전달, 반환 값 처리 등과 관련된 코드를 생성하는 방식을 정의한다.</br>
            여러 가지 종류가 있으며 대표적으로 cdecl, stdcall, fastcall에 대해 서술한다.</br>
            </br>
            <b>1. cdecl</b></br>
            C 언어의 표준 호출 규약으로 기본적으로 가장 많이 사용된다.</br>
            이 규약에서는 매개변수를 오른쪽에서 왼쪽으로 스택에 넣는다.</br>
            함수 호출이 완료되 후에 스택에서 매개변수를 제거하는 작업은 호출자가 담당한다.</br>
            이 규약은 가변 인수를 사용하는 함수에 적합하며 대부분의 C 컴파일러에서 기본값으로 사용된다.</br>
            </br>
            <b>2. stdcall</b></br>
            주로 Win32 API에서 사용되는 호출 규약이다.</br>
            cdecl과 유사하게 매개변수를 오른쪽에서 왼쪽으로 스택에 넣는다.</br>
            하지만 함수 호출이 완료된 후 스택에서 매개변수를 제거하는 작업은 함수(피호출자)가 담당한다.</br>
            이 규약은 스택 치우기 작업에 대한 일관성을 유지하고 호출자에게 부담을 덜어준다.</br>
            </br>
            <b>3. fastcall</b></br>
            퍼포먼스를 중시하는 호출 규약으로 일부 매개변수를 레지스터로 전달하여 스택 사용을 최소화한다.</br>
            이 규약은 프로세서의 레지스터를 활용하여 연산 속도를 높이고 스택 오버헤드를 줄인다.</br>
            </br>
            <b><font size=+2>치트엔진과 인증크랙의 원리</font></b></br>
            치트엔진은 주로 컴퓨터 게임에서 사용되는 메모리 값과 프로세스를 스캔하고 수정하여 플레이어가 게임 내에서 불공정한 이점을 얻을 수 있도록 하는 도구이다.</br>
            치트엔진의 작동 원리는 메모리 스캔과 수정 과정을 통해 이루어진다.</br>
            </br>
            <b>1. 메모리 스캔</b></br>
            치트 엔진은 먼저 게임이 실행되고 있는 프로세스 메모리에서 특정 값을 찾는다.</br>
            이 값은 게임 스코어, HP, 아이템의 수 등등 게임 진행에 중요한 역할을 하는 변수들이다.</br>
            사용자는 관심 있는 값의 초기 값을 정확하게 명시한 후 치트 엔진이 해당 값을 지닌 메모리 주소를 찾도록 한다.</br>
            </br>
            <b>2. 메모리 값 추적 및 필터링</b></br>
            게임 플레이가 진행되며 기록된 값이 변경되면 치트 엔진은 메모리를 계속 스캔하고 변경된 값에 해당하는 새 메모리 주소를 확인한다.</br>
            메모리 주소 후보가 계속 줄어들면서 사용자가 원하는 변수에 대응하는 정확한 메모리 주소가 결정된다.</br>
            </br>
            <b>3. 메모리 값 수정</b></br>
            사용자가 해당 메모리 주소의 값을 원하는 값으로 수정하면 게임 내 요소가 그에 맞춰 바뀐다.</br>
            예로, 게임 내의 돈의 값을 바꾸면 원하는 액수의 값으로 바뀐다.</br>
            </br>
            인증 크랙도 보통 유료 소프트웨어를 불공정한 방법으로 무료로 사용하려는 의도에서 나왔기 때문에 치트 엔진과 결이 같다고 할 수 있다.</br>
            인증 크랙은 소프트웨어의 라이선스 인증 기능을 우회하거나 비활성화하는데 사용된다.</br>
            인증 크랙의 주요 원리는 주로 소프트웨어의 보안 및 인증 메커니즘을 수정하거나 제거하는 것이다.</br>
            </br>
            <b>1. 코드 분석</b></br>
            인증 크랙의 첫 단계는 리버스 엔지니어링을 사용하여 소프트웨어가 어떻게 라이선스 인증을 수행하는지 분석하는 것이다.</br>
            이는 디스어셈블러, 디버거 등의 도구를 사용해 실행 파일을 역으로 분석하여 이루어진다.</br>
            </br>
            <b>2. 인증 우회</b></br>
            인증 크랙의 두 번째 단계는 소프트웨어의 인증 과정에서 발생하는 메커니즘을 변경하거나 제거하는 것이다.</br>
            이는 아래과 같은 방법들이 있다.</br>
            </br>
            - 키 생성: 소프트웨어 인증에 필요한 유효한 라이선스 키를 생성하는 키젠 도구를 만든다.</br>
            - 패치 작성: 소프트웨어 실행 파일의 일부분을 수정하여 인증 과정을 건너뛰거나 성공적인 인증 결과를 반환하도록 한다.</br>
            - 액티베이션 서버 에뮬레이션: 인증 서버의 역할을 하는 프록시 서버로 요청을 전달하여 허가된 인증을 얻는 것처럼 만든다.</br>
            </br>
            <b><font size=+2>서버-소켓 구조</font></b></br>
            서버-소켓 구조는 컴퓨터 네트워크에서 서버와 클라이언트 간에 정보를 주고받기 위해 사용되는 통신 모델이다.</br>
            서버는 제공되는 서비스를 관리하고 클라이언트는 서버의 서비스를 사용한다.</br>
            이러한 통신을 위해서는 소켓이라는 특별한 네트워크 인터페이스를 사용한다.</br>
            이 구조에는 크게 4가지 주요 구성 요소가 있다.</br>
            </br>
            <b>1. 서버</b></br>
            서비스를 제공하는 컴퓨터 또는 프로세스이며, 요청을 처리하고 클라이언트에게 결과를 반환한다.</br>
            </br>
            <b>2. 클라이언트</b></br>
            서버의 제공하는 서비스를 요청하고 사용하는 컴퓨터 또는 프로세스.</br>
            </br>
            <b>3. 소켓</b></br>
            서버와 클라이언트 간에 데이터를 주고받기 위한 엔드포인트로 IP주소와 포트 번호를 통해 식별된다.</br>
            프로그래밍 환경에서 소켓은 특정 API를 사용하여 프로그램에서 접근할 수 있는 추상화된 객체로 제공된다.</br>
            </br>
            <b>4. 프로토콜</b></br>
            서버-소켓 구조에서 서버와 클라이언트 간 통신을 가능하게 하는 데 사용되는 규칙이 정의된 표준이다.</br>
            일반적으로 TCP나 UDP와 같은 전송 계층 프로토콜이 사용된다.</br>
            </br>
            <b><font size=+2>클라이언트-소켓 구조</font></b></br>
            클라이언트-소켓은 위 서버-소켓 구조와 비슷하지만 차이점이 있다.</br>
            클라이언트-소켓은 클라이언트 소켓을 생성한 후 서버의 IP 주소와 포트를 사용하여 서버에 연결을 요청한다.</br>
            연결이 성립되면 클라이언트는 서버에 데이터를 전송하고 응답을 받는다.</br>
            서버-소켓은 서버 소켓을 생성하고 자신의 IP 주소와 포트를 이용해 소켓을 바인딩한 후 클라이언트의 연결 요청을 기다린다.</br>
            연결 요청이 들어오면 서버는 연결을 수락하고 데이터를 주고받기 위한 소켓을 생성한다.</br>
            </br>
            <b><font size=+2>블로킹과 논블로킹</font></b></br>
            둘 다 네트워크 통신에서 많이 사용되는 용어이다.</br>
            시스템이 작업을 수행하거나 작업 결과를 기다릴 때 동작 방식이 결정된다.</br>
            </br>
            <b>블로킹</b></br>
            블로킹 방식에서는 작업이 완료될 때까지 프로그램의 실행이 일시 중지되어 다른 작업을 수행할 수 없다.</br>
            작업이 진행되는 동안 프로그램은 작업 반환값을 기다리며 추가적인 명령을 처리하지 않는다.</br>
            예를 들어, 블로킹 모드로 파일을 읽거나 네트워크 통신을 하는 경우, 해당 작업이 완료되어야만 프로그램이 다른 태스크를 처리할 수 있다.</br>
            </br>
            <b>논블로킹</b></br>
            논블로킹 방식은 작업이 완료되지 않더라도 프로그램이 다른 작업을 계속 수행할 수 있는 방식이다.</br>
            이 경우 프로그램은 작업이 완료되지 않았을 때 인터럽션이 발생하거나 작업 완료 여부를 가리키는 상태 값을 반환할 수 있다.</br>
            결과적으로 프로그램은 다른 작업을 수행하면서 주기적으로 완료된 작업 결과를 확인할 수 있다.</br>
            </br>
    </BODY>
</HTML>