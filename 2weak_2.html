<HTML>
    <HEAD>
      <TITLE>2weak_1</TITLE>
    </HEAD>
    <BODY>
        </br>
        <b><font size=+3>REVIEW</font></b></br>
            </br>
            <b><font size=+2>파일 사용자와 그룹</font></b></br>
            리눅스 안에서 파일 및 경로에 파일 사용자와 그룹이 있다.</br>
            이렇게 나눠놓은 이유는 접근 권한을 세세하게 지정하기 위해서이다.</br>
            리눅스에서는 소유자와 그룹 사용자에 관련한 명령어들이 있다.</br>
            </br>
            <b>- chmod 명령어</b></br>
            파일과 디렉토리의 권한을 변경할 때 사용한다.</br>
            <b>chmod [권한] [변경할 파일 또는 디렉토리]</b></br>
            형식은 이러하며, 변경하는 방법에는 개별단위로 권한부여와 숫자로 변경하는 방법이 있다.</br>
            </br>
            <b>- chown 명령어</b></br>
            파일과 디렉토리의 소유주를 변경할 떄 사용한다.</br>
            </br>
            <b>chown [소유주] [변경할 파일]</b></br>
            파일의 소유주를 변경한다.</br>
            </br>
            <b>chown [소유주] [변경할 디렉토리]</b></br>
            디렉토리 소유주를 변경한다.</br>
            </br>
            <b>chown [소유주]:[그룹] [변경할 디렉토리]</b></br>
            파일의 소유주와 그룹을 동시에 변경한다.</br>
            </br>
            <b>- chgrp 명령어</b></br>
            파일의 그룹만 변경할 때 사용한다.</br>
            <b>chgrp [그룹] [변경할 파일]</b></br>
            파일의 그룹을 변경한다.</br>
            </br>
            <b><font size=+2>netstat</font></b></br>
            netstat 명령어는 네트워크 연결 상태, 라우팅 테이블, 인터페이스 상태 등을 보여주는 명령어.</br>
            "Active Internet connections(인터넷 연결상태)" 부분과 "Active UNIX domain sockets(도메인 소켓 연결 상태)"으로 나뉘어져서 표시.</br>
            -na 옵션을 입력할 경우, 현재 시스템의 모든 네트워크 연결 목록을 표시.</br>
            아래는 주요 옵션들이다.</br>
            </br>
            <b>-n</b></br>
            호스트명, 포트명을 lookup하지 않고 그대로 IP, Port번호로 보여줌.</br>
            </br>
            <b>-a</b></br>
            모든 네트워크 연결상태를 보여준다.</br>
            </br>
            <b>-l</b></br>
            LISTEN 상태인 서비스 포트를 보여준다.</br>
            LISTEN 상태는 응답 대기 상태로서 로컬 엔드포인트에서 원격 엔드포인트로부터 연결 요청을 수신하고 있다는 의미이다.</br>
            </br>
            <b>-t</b></br>
            TCP 프로토콜만 보여준다.</br>
            </br>
            <b>-u</b></br>
            UDP 프로토콜만 보여준다.</br>
            </br>
            <b>-p</b></br>
            해당 포트를 사용하는 프로그램과 프로세스ID(PID)를 보여준다.</br>
            </br>
            <b>-r</b></br>
            라우팅 테이블을 출력한다.</br>
            라우팅 테이블은 네트워크상의 특정 목적지까지의 거리와 가는 방법등을 명시하고 있는 테이블이다.</br>
            우리가 주소를 보고 어딘가를 찾아가듯이 라우터는 어딘가를 찾아갈 때 라우팅 테이블을 보고 찾아간다.</br>
            </br>
            <b>-s</b></br>
            프로토콜별로 통계를 보여준다.</br>
            프로토콜에 속해있는 것들은 IP, ICMP, TCP, UDP 등이 속한다.</br>
            </br>
            netstat 명령어의 상태값은 다음과 같다.</br>
            </br>
            <b>CLOSED</b></br>
            완전히 연결이 종료된 상태.</br>
            </br>
            <b>CLOSING</b></br>
            보기 힘든 상태지만 주로 확인 메세지가 전송 도중 유실된 상태.</br>
            </br>
            <b>CLOSE_WAIT</b></br>
            TCP 연결이 상위 응용프로그램 레벨로부터 연결 종료를 기다리는 상태.</br>
            </br>
            <b>ESTABLISHED</b></br>
            서버와 클라이언트 간에 세션 연결이 성립되어 통신이 이루어지고 있는 상태.</br>
            클라이언트가 서버의 SYN을 받아서 세션이 연결된 상태로도 볼 수 있다.</br>
            </br>
            <b>FIN_WAIT1</b></br>
            클라이언트가 서버에게 연결을 끊고자 요청하는 상태.(FIN을 보낸 상태)</br>
            </br>
            <b>FIN_WAIT2</b></br>
            서버가 클라이언트로부터 연결 종료 응답을 기다리는 상태.</br>
            서버가 클라이언트로부터 FIN을 받은 후, 클라이언트에게 ACK를 보냈을 때를 말한다.</br>
            </br>
            <b>LAST_ACK</b></br>
            호스트가 원격지 호스트의 연결 종료 요구 승인을 기다리는 상태.(서버가 클라이언트에게 FIN을 보냈을 때)</br>
            </br>
            <b>LISTEN</b></br>
            -l 옵션에서 서술했듯이 서버의 데몬(daemon)이 떠 있어서 클라이언트의 접속 요청을 기다리고 있는 상태.</br>
            데몬은 서비스의 요청에 대해 응답하기 위해 오랫동안 실행중인 백그라운드 프로세스이다.</br>
            </br>
            <b>SYN_SENT</b></br>
            클라이언트가 서버에게 연결을 요청한 상태.</br>
            </br>
            <b>SYN_RECEIVED</b></br>
            서버가 클라이언트로부터 접속 요구(SYN)를 받아 클라이언트에게 응답(SYN/ACK) 했지만, 아직 클라이언트에게 확인 메세지(ACK)는 받지 못한 상태.</br>
            </br>
            <b>TIME_WAIT</b></br>
            연결은 종료되었지만 잠시 소켓을 열어놓은 상태, 약 1분정도 소켓을 열어놓으며 시간이 지나면 사라짐.</br>
            </br>
            <b>UNKNOWN</b></br>
            소켓의 상태는 알 수 없음.</br>
            </br>
            <b><font size=+2>ufw</font></b></br>
            데비안 계열 및 다양한 리눅스 환경에서 작동되는 방화벽 관리 프로그램.</br>
            사용하기 쉽게 설계된 넷필터 방화벽을 관리하는 프로그램으로 간단한 명령 및 명령수가 적은 CLI(Command-Line Interface)를 사용한다.</br>
            서버는 어디서든지 외부 접근이 가능하기 때문에 보안 위험에 노출될 수 있다.</br>
            때문에 ufw같은 방화벽 관리 프로그램으로 방화벽을 관리하여 접근을 컨트롤 해야한다.</br>
            </br>
            <b><font size=+2>service</font></b></br>
            소프트웨어적인 service로는 SaaS, PaaS, IaaS같은 특정 업체에서 제공해주는 서비스이다.</br>
            네이버, 구글 등 웹 서비스를 제공해주는 회사들이 유명하고 이런 것들을 서비스라고 한다.</br>
            </br>
            <b><font size=+2>branch</font></b></br>
            git에 있는 기능으로 독립적으로 어떤 작업을 진행하는 개념이 branch이다.</br>
            소프트웨어를 개발할 때, 개발자들은 동일한 소스코드를 함께 공유하고 다루게 된다.</br>
            동일한 소스코드 위에서 어떤 개발자는 버그를 수정하기도 하고 또 다른 개발자는 새로운 기능을 만들어 내기도 한다.</br>
            각각의 다른 사람들이 동일한 소스코드에서 다른 작업을 수행하기에 다른 버전의 코드가 만들어 질 수 밖에 없다.</br>
            이를 위해 branch라는 기능을 이용해 독립적인 작업 영역(저장소)를 만들어 마음대로 소스코드를 변경 가능하다.</br>
            이렇게 분리된 작업 영역에서 변경된 내용은 나중에 원래의 버전과 비교해서 하나의 새로운 버전으로 만들 수 있다.</br>
            <b><font size=+2>stash</font></b></br>
            만약, 자신이 어떠한 작업을 하던 도중, 다른 요청이 들어와 하던 작업을 멈추고 잠시 branch를 변경해야할 일이 있다고 예를 든다.</br>
            이때, 아직 완료하지 않은 일을 commit하는 것은 보통 껄끄럽다.</br>
            stash 명령어는 아직 마무리하지 않은 작업을 스택에 잠시 저장할 수 있도록 하는 명령어이다.</br>
            이렇게 되면 commit하지 않고 잠시 stash에 보관해 놓았다가 나중에 다시 꺼내 마무리가 가능하다.</br>
            </br>
            <b><font size=+2>merge</font></b></br>
            기존 branch를 다른 branch와 합칠 때 merge 명령어를 사용한다.</br>
            merge의 기본 단위는 branch이며, merge 명령어로는 commit 단위로 합치기는 불가능하다.</br>
            </br>
            <b>Fast Forward Merge</b></br>
            가장 기본적인 merge가 바로 Fast Forward Merge이다.</br>
            이는 현재 브랜치의 HEAD가 대상 브랜치의 HEAD까지로 옮기는 것이다.</br>
            하지만 이는 단점이 있는데, Fast Forward Merge는 중간에 변경이 없을 때만 동작한다.</br>
            만약, 중간에 다른 commit이 껴 있고, 해당 commit이 같은 부분을 수정했다면 CONFLICT가 일어나 제대로 동작하지 않는다.</br>
            예로, 특정 파일을 동시에 수정한 main 브랜치의 fifth commit과 feature-layout branch의 fourth commit이 있을 경우, CONFLICT 에러가 뜬다.</br>
            </br>
            <b><font size=+2>conflict</font></b></br>
            위에 서술한 merge 명령어에서 오류가 나면 보통 conflict가 발생한다.</br>
            이는 merge 과정에서 파일의 이름이 같고 수정한 부분이 같으면 발생한다.</br>
            보통 이 상황에서는 git status 명령어로 충돌이 일어난 파일을 찾고, 그 파일들의 내용이나 이름을 수정하면 된다.</br>
            </br>
            <b><font size=+2>Jenkins</font></b></br>
            Hava Runtime Environment에서 동작하며, 소프트웨어 개발 시 지속적으로 통합 서비스를 제공하는 툴이다.</br>
            CI(Continuous Integration) 툴 이라고 표현한다.</br>
            다수의 개발자들이 하나의 프로그램을 개발할 때 버전 충돌을 방지하기 위해 각자 작업한 내용을 공유 영역에 있는 저장소에 자주 업로드 함으로써 지속적 통합을 가능케 한다.</br>
            개발중인 프로젝트에서 commit은 매우 빈번하게 일어나기 때문에 commit 횟수만큼 빌드를 실행하는 것이 아닌 작업이 queuing되어 자신이 실행될 차례를 기다린다.</br>
            코드의 변경과 함께 이뤄지는 자동화된 빌드와 테스트 작업들은 이런 이점들이 있다.</br>
            </br>
            <b>- 프로젝트 표준 컴파일 환경에서의 컴파일 오류 검출</b></br>
            </br>
            <b>- 자동화 테스트 수행</b></br>
            </br>
            <b>- 정적 코드 분석에 의한 코딩 규약 준수여부 체크</b></br>
            </br>
            <b>- 프로파일링 툴을 이용한 소스 변경에 따른 성능 변화 감시</b></br>
            </br>
            <b>- 결합 테스트 환경에 대한 배포작업</b></br>
            </br>
            크게 보이는 장점으로는 다음과 같은 것이 있다.</br>
            </br>
            <b>각종 배치 작업의 간략화</b></br>
            프로젝트 기간 중에 개발자들은 순수한 개발 작업 이외에 DB 셋업이나 환경설정, Deploy 작업과 같은 단순 작업에 시간과 노력을 들이는 경우가 빈번하다.</br>
            데이터베이스 구축, 애플리케이션 서버로의 Deploy, 라이브러리 릴리즈와 같이 CLI로 실행되던 작업들이 Jenkins 덕분에 웹 인터페이스로 쉽게 가능해졌다.</br>
            </br>
            <b>Build 자동화의 확립</b></br>
            빌드 툴의 경우 Java는 maven과 gradle이 자리잡고 있으며, 이미 빌드 관리 툴을 이용해 프로젝트를 진행하고 있다면 Jenkins를 사용 안할 이유가 없다.</br>
            Jenkins와 연동하여 빌드 자동화를 통해 프로젝트 진행의 효율성을 높일 수 있다.</br>
            </br>
            <b>자동화 테스트</b></br>
            Jenkins를 사용해야 하는 이유 중 하나이며, 사실상 자동화 테스트가 포함되지 않으면 CI자체가 불가능 하다고 할 수 있다.</br>
            Jenkins는 Subversion이나 Git 같은 버전 관리 시스템과 연동하여 코드 변경을 감지하고 자동화 테스트를 수행하기 때문에 만약 개인이 미처 실시하지 못한 테스트가 있다 해도 든든한 안전망이 되어준다.</br>
            </br>
            <b>코드 표준 준수여부 검사</b></br>
            자동화 테스트와 마찬가지로 개인이 미처 실시하지 못한 코드 표준 준수 여부의 검사나 정적 분석을 통한 코드 품질 검사를 빌드 내부에서 수행함으로써 기술적 부채의 감소에도 크게 기여한다.</br>
            </br>
            <b>빌드 파이프라인 구성</b></br>
            2개 이상의 모듈로 구성되는 레이어드 아키텍처가 적용 된 프로젝트에는 그에 따른 빌드 파이프라인 구성이 필요하다.</br>
            예로, 도메인 -> 서비스 -> UI와 같이 각 레이어의 참조 관계에 따라 순차적으로 빌드를 진행하지 않으면 안된다.</br>
            Jenkins는 이러한 빌드 파이프라인 구성을 간단히 할 수 있으며, 스크립트를 통해서 매우 복잡한 제어까지도 가능하다.</br>
            </br>
            <b><font size=+2>ps와 kill</font></b></br>
            ps는 프로세스이며 이는 리눅스 시스템에서 메모리에 적재되어 실행되고 있는 모든 프로그램을 뜻한다.</br>
            프로그램은 명령어들의 집합체이며 프로세스는 그 명령어 집합체 중에서 현재 실행중인 것을 의미한다.</br>
            ps 명령어의 틀은 다음과 같다.</br>
            </br>
            <b>ps [option]</b></br>
            </br>
            ps 명령어의 옵션들은 다음과 같다.</br>
            </br>
            <b>-e</b></br>
            현재 실행 중인 모든 프로세스 정보 출력.</br>
            </br>
            <b>-f</b></br>
            모든 정보 확인.</br>
            </br>
            <b>-a</b></br>
            실행중인 전체 사용자의 모든 프로세스 출력.</br>
            </br>
            <b>-u</b></br>
            프로세스를 실행한 사용자와 프로세스 시작 시간 등을 출력.</br>
            </br>
            <b>-x</b></br>
            터미널 제어 없이 프로세스 현황 보기, 실시간으로 터미널에 프로세스가 어떻게 변하는지 보여준다.</br>
            </br>
            kill 명령어는 위에 서술한 프로세스를 종료시키는 명령어이다.</br>
            kill 명령어의 틀은 이러하다.</br>
            </br>
            <b>kill [option] [PID]</b></br>
            </br>
            옵션은 다음과 같다.</br>
            </br>
            <b>-l</b></br>
            사용 가능한 시그널 목록을 출력.</br>
            </br>
            <b>-1</b></br>
            재실행.(SIGHUP)</br>
            <b>-9</b></br>
            강제 종료.(SIGKILL)</br>
            </br>
            <b>-15</b></br>
            정상 종료.(SIGTERM)</br>
            </br>
    </BODY>
</HTML>